#include "saver.hpp"
#include "globals.hpp"
#include <cassert>

#include <cmath>
#include <iostream>

Saver::Saver() {
    //save();
    //load();
}

Saver::~Saver() {
    // save();
}

byte Saver::rbyte() {
    char c;
    m_if.read((char *)&c, 1);
    return c;
}

std::vector<bool> Saver::rbools() {
    byte count = rbyte();
    std::vector<byte> bytes(std::ceil((float)count / 8));
    for (int i = 0; i < bytes.size(); i++) {
        bytes[i] = rbyte();
    }
    std::vector<bool> bools(count);
    for (int i = 0, j = 0; i < count; i++) {
        j = i % 8 == 0 ? j++ : j;
        bools[i] = (bytes[j] >> (i % 8)) & 1;
    }
    return bools;
}

short Saver::rshort() { return rbyte() << 8 | rbyte() << 0; }

int Saver::rint() { return rbyte() << 24 | rbyte() << 16 | rbyte() << 8 | rbyte() << 0; }

std::string Saver::rstring() {
    short size = rshort();
    std::string str;
    for (int i = 0; i < size; i++) {
        str += rbyte();
    }
    return str;
}

SDL_FPoint Saver::rpoint() { return {(float)rint(), (float)rint()}; }

SDL_Color Saver::rcolor() { return {rbyte(), rbyte(), rbyte(), rbyte()}; }

Saver::GateData Saver::rgate() {
	GateData gate;

    gate.type = rbyte();
    gate.pos = rpoint();
    gate.color = rcolor();
    gate.name = rstring();
    gate.typeArrayIndex = rint();

    gate.outputNodes.resize(rint());
	for (auto &node : gate.outputNodes) {
		node.p = rpoint();
        node.connectedGateActiveArrayIndex = rint();
		node.c = rcolor();
        node.name = rstring();
    }
    std::vector<bool> states = rbools();
	assert(states.size() == gate.outputNodes.size());
	for (int i = 0; i < gate.outputNodes.size(); i++) {
		gate.outputNodes[i].state = states[i];
	}

	gate.inputNodes.resize(rint());
	for (auto &node : gate.inputNodes) {
        node.p = rpoint();
		SDL_Log("node pos %f %f", node.p.x, node.p.y);
        node.connectedGateActiveArrayIndex = rint();
        node.connectedNodeIndex = rint();
		SDL_Log("node's indices %i %i", node.connectedGateActiveArrayIndex, node.connectedNodeIndex);
        node.nodeLines.resize(rbyte());
		for (int i = 0; i < node.nodeLines.size(); i++) {
            node.nodeLines[i] = rpoint();
        }
        node.c = rcolor();
        node.name = rstring();
    }

    if (gate.type == 4) {
		gate.customGateData.resize(rint());
		for (int i = 0; i < gate.customGateData.size(); i++) {
			gate.customGateData[i] = rgate();
		}
    }

	return gate;
}

void Saver::load() {
    SDL_Log("Saver::load");
    m_if.open("data.piss");

	std::vector<GateData> gateData(rint());
	for (int i = 0; i < gateData.size(); i++) {
		gateData[i] = rgate();
	}
	for (auto g : gateData) {
		SDL_Log("type %i, pos %f %f, color %i %i %i %i, name %s, typeIndex %i", g.type, g.pos.x, g.pos.y, g.color.r, g.color.g, g.color.b, g.color.a, g.name.c_str(), g.typeArrayIndex);
		SDL_Log("outputNodes %zu", g.outputNodes.size());
		for (auto &node : g.outputNodes) {
			SDL_Log("pos %f %f, index %i, color %i %i %i %i, name %s, state %b", node.p.x, node.p.y, node.connectedGateActiveArrayIndex, node.c.r, node.c.g, node.c.b, node.c.a, node.name.c_str(), node.state);
		}
		SDL_Log("inputNodes %zu", g.inputNodes.size());
		for (auto &node : g.inputNodes) {
			SDL_Log("pos %f %f, gate index %i, node index %i, node line size %zu, color %i %i %i %i, name %s", node.p.x, node.p.y, node.connectedGateActiveArrayIndex, node.connectedNodeIndex, node.nodeLines.size(), node.c.r, node.c.g, node.c.b, node.c.a, node.name.c_str());
			std::string points = "";
			for (auto &p : node.nodeLines) {
				points += std::format("{}:{}, ", p.x, p.y);
			}
			SDL_Log("%s", points.c_str());
		}
	}

    m_if.close();
    SDL_Log("~Saver::load");
}

// ----------------------------------------------------------------------------------------------------------------------------------------

void Saver::wbyte(byte b) { m_of.write((char *)&b, 1); }

void Saver::wbools(std::vector<bool> bools) {
    wbyte((byte)bools.size());
    for (int i = 0; bools.size() - i >= 8; i += 8) {
        if (bools.size() - i < 8) {
            int required = 8 - bools.size();
            for (int i = 0; i < required; i++) {
                bools.push_back(0);
            }
        }
        char c{};
        for (int i = 0; i < bools.size(); i++) {
            c |= bools[i] << i;
        }
        wbyte(c);
    }
}

void Saver::wshort(short s) {
    wbyte(s >> 8);
    wbyte(s >> 0);
}

void Saver::wint(int i) {
    wbyte(i >> 24);
    wbyte(i >> 16);
    wbyte(i >> 8);
    wbyte(i >> 0);
}

void Saver::wstring(std::string s) {
    wshort(s.size());
    for (char &c : s) {
        wbyte(c);
    }
}

void Saver::wpoint(SDL_FPoint p) {
    wint(p.x);
    wint(p.y);
}

void Saver::wcolor(SDL_Color c) {
    wbyte(c.r);
    wbyte(c.g);
    wbyte(c.b);
    wbyte(c.a);
}

void Saver::wgate(std::shared_ptr<Gate> g, std::vector<std::shared_ptr<Gate>> &context) {
    int gateType = 5;
    if (std::dynamic_pointer_cast<AndGate>(g)) {
        gateType = 0;
    } else if (std::dynamic_pointer_cast<NotGate>(g)) {
        gateType = 1;
    } else if (std::dynamic_pointer_cast<InputGate>(g)) {
        gateType = 2;
    } else if (std::dynamic_pointer_cast<OutputGate>(g)) {
        gateType = 3;
    } else if (std::dynamic_pointer_cast<CustomGate>(g)) {
        gateType = 4;
    }
    assert(gateType != -1);
    wbyte(gateType);
    wpoint({g->realpos().x, g->realpos().y});
    wcolor(g->color());
    wstring(g->name());
    wint(g_context.gateNameToIndex(g->name())); // index into gate TYPES array

    wint(g->maxOutput());
    for (int i = 0; i < g->maxOutput(); i++) {
        auto outNode = g->getOutputNode(i).lock();
        wpoint(outNode->p);

		auto toGate = outNode->toGate.lock();
		for (int j = 0; j < context.size(); j++) {
			if (context[j] == toGate) {
				wint(j); // index into context
				break;
			}
		}
        wcolor(outNode->c);
        wstring(outNode->name);
    }
    wbools(g->states());

    wint(g->maxInput());
    for (int i = 0; i < g->maxInput(); i++) {
        auto inNode = g->getInputNode(i).lock();
        wpoint(inNode->p);
		if (inNode->connected.expired()) {
			wint(1000);
			wint(1000);
		} else {
			auto toGate = inNode->toGate.lock();
			for (int j = 0; j < context.size(); j++) {
				if (context[j] == toGate) {
					wint(j); // index into context
					break;
				}
			}
			wint(g_context.getGateIndex(inNode->connected.lock()->owner.lock()));
			wint(inNode->connected.lock()->owner.lock()->getOutputNodeIndex(inNode->connected));
		}
        wbyte(inNode->lineNodes.size());
        for (auto p : inNode->lineNodes) {
            wpoint(p);
        }
        wcolor(inNode->c);
        wstring(inNode->name);
    }

    // custom gate
    if (gateType == 4) {
		const auto &customContext = std::dynamic_pointer_cast<CustomGate>(g)->context();
		wint(customContext.size());
        for (auto gc : customContext) {
            // dont get scared this is fine
            wgate(gc);
        }
    }
}

void Saver::save() {
    SDL_Log("Saver::save");
    m_of.open("data.piss");

	wint(g_context.activeGateCount());
	for (int i = 0; i < g_context.activeGateCount(); i++) {
		wgate(g_context.activeGates()[i]);
	}

    m_of.close();
    SDL_Log("~Saver::save");
}
